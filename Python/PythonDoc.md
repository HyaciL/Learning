# Python Document   
---

## 1 前言
Python是一种解释型语言，不需要编译和链接
> Java & C# 可以称为混合型语言,既有虚拟机进行运行,如Java又有CodeType字节码进行中间的储存;


## 2 使用Python的解释器
> **GNU Readline Library**,提供了一系列允许用户操作命令行的函数,包括交互式编辑,里氏替换,代码补全等;

### 2.1 唤出解释器
详见文档
#### 2.1.1 传入参数
解释器读取命令行参数,把脚本名和其他参数转化为字符串列表存在**sys模块**的**argv**变量中,执行**import sys**可以导入这个模块并访问列表;
#### 2.1.2 交互模式
**主提示符 >>>**,以及输入连续行时的**次要提示符 ...** 
### 2.2 解释器的运行环境
#### 2.2.1 源文件的字符编码
默认为UTF-8;
如果不使用默认编码,则要声明编码,第一行使用特殊注释:
~~~python
# -*- coding: encoding -*- 
# encoding 可以为任意一种python支持的codecs
~~~


## 3 Python速览
- Python注释以 **#** 开头;

> Python中的数据都是对象
> Python中的对象分为可变对象和不可变对象
> 不可变对象无法改变自身(如x=3中的3),但可以改变引用的对象(如再令x=4),此时地址变化
> 函数的传值是一种传对象引用的方式
> 若不想改变可改变对象,可传入副本,如list[:]

### 3.1 Python用作计算器

#### 3.1.1 数字
解释器像一个简单的计算器, 表达式语法中: 
- **那四个符号**用来执行算术运算, **圆括号**用来进行分组;
- 计算整数结果可以用 "//" ,计算余数用 "%"
- "**" 计算乘方
- "=" 赋值
- 未定义的变量使用会报错
- 混合类型运算数的运算会把整数转换为浮点数
- 交互模式下,上次输出的表达式值会给赋给变量"_",如果为其显式赋值,会创建一个同名独立局部变量,覆盖掉内置变量
- 还支持 Decimal 和 Fraction 还内置复数

#### 3.1.2 文本
Python可以操作文本,以**str**类型标识,称为**字符串**,使用成都的单引号或双引号来表示
- 如果使用两种引号在一个str中,"\"转义字符无用
- 如果使用print()方式,转义字符会被转义显示;
- 原始字符串 在引号前添加"r";
- 字符串字面值可以包含多行, 如使用 三重引号"""..."""|'''...'''
- 字符串可以用"+"粘合,也可以用"*"重复
- 相邻的会自动合并(只能是字面值)
- 字符串第一个**字符索引**为0,符号为从右开始
- 除了索引,还有**切片**,如word[:2](从开始到2) 
  > (包含切片开始,不包切片结束) 如'Python' [:2]为'Py';
- Python字符串不能修改
- 内置函数len()返回长度

#### 3.1.3 列表
**列表**使用方括号标注,逗号分隔的一组值,可以包含不同类型元素,但一般为相同类型;
- 列表也支持索引和切片
- 列表也支持合并(+)
- 列表时mutable类型,内容可以改变
- 可以通过list.append()方法,添加新条目
- 为切片赋值可以改变列表,甚至清除(letters[:]= [])
- 内置函数len()也支持列表
- 存在嵌套列表

### 3.2 编程第一步
~~~python
>>> a, b = 0, 1
>>> while a < 10:
...     print(a)
...     a, b = b, a+b
...
~~~
- 循环体是缩进的
- print()支持多个参数,输出的字符串不显示引号,且参数之间会加入一个空格
- print()关键字参数**end**可以取消后面输出的换行,或者用 end="字符串"来代替换行

>**优先级高于-


## 更多控制流工具
除了刚才的while,还有如下控制流工具

### 4.1 if语句
- 可有0或多个elif部分,else部分也是可选

### 4.2 for语句
for语句需要在列表或字符串等任意序列元素迭代,如
>>> for w in words: 
...    print(w, len(w))
> 想要迭代的同时进行修改,可以通过迭代多项集副本或创建新的多项集

### 4.3 range()函数
内置range()函数用来生成等差数列
~~~python
for i in range(5):
    print(i)
#   0,1,2,3,4
~~~
- range()函数三个参数可以有起始值,结束值,以及步长
- for i in range(len(a)): 即可按索引迭代
- 绝大多数情况下enumerate()很方便
> range()打印时并不会打印列表项,返回的对象是: range(0,number),没有真正生成一个列表,节省了空间
> 这种对象被称为**可迭代对象iterable**,适合作为需要获取一系列值的函数或程序的构件,如for就是这样的程序,而sum()就是这样的函数

### 4.4 循环中的break & continue语句 以及 else子句
- break将跳出最近的一层for 或 while,同时会取消else子句的执行
- else 会在循环条件变为假值的时候成立(就像try语句)
- continue,执行下一次迭代

### 4.5 pass语句
不执行任何动作,通常用于创建一个最小类
~~~python
class MyEmptyClass
    pass
~~~
- 还可以用于函数或条件语句体的占位符

### 4.6 match语句
接受一个表达式并把它的值和一个或多个case块给出的一系列模式进行比较,像是C中的switch,但其实更像Rust中的模式匹配,只有一个匹配的会被执行;
match status:
    case 400:
        return ""

- 可以用 |或() 将多个字面值组合到一个模式里
> 解包赋值: 解包基本上意味着从序列（如列表、元组）中提取值并将它们分配给变量。
- 解包赋值可以用于绑定变量
- **详情看文档,我没看明白  ?**        **大致明白了**
- 比如一个二元组,从(0,0)到(0,y)到(x,0)最后(x,y),可以达到解包赋值(x,y) = point的效果
- 如果用类组织数据,可以用类名接一个参数列表这种像构造器的形式,捕获变量
- 自定义类可通过在类中设置特殊属性 __match_args__，为属性指定其在模式中对应的位置。
- 可以为模式添加 if 作为守卫子句。如果守卫子句的值为假，那么 match 会继续尝试匹配下一个 case 块。
- 还有一些其它关键特性，看文档吧

### 4.7 定义函数
定义函数使用关键字**def**, 后跟函数名和参数列表，函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring。
- 使用函数参数时：先使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；然后，是外层函数局部符号表->全局符号表->内置名称符号表
- 可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是 global 语句定义的全局变量，或 nonlocal 语句定义的外层函数变量）
- 在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 按值调用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）

> ***这一块看文档吧,都挺重要的***


### 4.8 函数定义详解

以下为三种函数定义支持的可变数量参数的使用形式
#### 4.8.1 默认值参数
> **in** 关键字用于确定序列里是否包含某个值     >>> if reply in {'y', 'yes', 'ye'}:

- 若给形参的默认参数为变量,默认值会在定义作用域的函数定义中求值.
- 当默认值为列表|字典|类实例时,有些函数会累积后续调用时传递的参数
> 因为默认参数只在定义时计算一次并保存下来,后续变化不会重新计算
- 不想共享默认值时,使用如下编写方式
    ~~~python
    def(a,L = []):
        if L is None:
            L = []
        L.append(a)
        return L
    ~~~
此时L = []给函数传入了新的列表,会覆盖掉默认参数,不会改变默认值

#### 4.8.2 关键字参数
- 函数调用时,关键字参数必须在位置参数之后;
> 最后一个形参为**name形式时,接收一个字典,该字典包含与函数中已定义形参对应之外的所有关键字参数,若与*name结合使用,则*name接收一个元组,包含形参列表之外的位置参数;


#### 4.8.3 特殊参数
默认情况下,参数可以按位置和关键字传递给函数,也可以通过 * 和 / 规定
- / 前只能为位置参数
- *后只能为关键字参数
- **具体看文档吧**

#### 4.8.4 任意实参列表

#### 4.8.5 解包实参列表
用 * 操作符 可以把实参从列表或元组中解包出来,用** 操作符解包字典来**传递关键字参数**;

#### 4.8.6 Lambda表达式
Lambda关键字用于创建小巧的匿名函数,如   Lambda a, b: a+b 函数返回两个参数的和;
~~~python
def make_incrementor(n):
    return lambda x: x+n

    f = make_incrementor(42)
    f(0)
    # 42
    f(1)
    # 43
~~~
上例用lambda 表达式返回函数
~~~python
pairs = [(1,'one'), (2, 'two'), (3, 'three'), (4,'four')]
pairs.sort(key = lambda pairs: pair[1])
pairs
    # [(1,'one'), (2, 'two'), (3, 'three'), (4,'four')]
~~~
以上将匿名函数作为传递的实参

#### 4.8.7 文档字符串
具体书写方式见文档
#### 4.8.8 函数注解
具体书写方式见文档
### 4.9 编码风格
具体书写方式见文档



## 数据结构

### 5.1 列表详解

**列表方法见文档**
- insert, remove | sort 等仅修改列表的方法不会打印返回值,它们返回默认值None,

#### 5.1.1 实现堆栈
- 实现栈非常简单,用append()和pop();

#### 5.1.2 列表实现队列
- 用列表实现队列的效率很低,因为在末尾添加和删除元素非常快,但在开头插入或移除很慢(其他元素必须移动一位),最好用collections.deque实现;
~~~python
from collections import deque 
queue = deque(["1", "2", "3"])
queue.append("4")
queue.popleft()
    # "" 
~~~

#### 5.1.3 列表推导式

~~~python
squares = [x**2 for x in range(10)]
~~~
- 列表推导式的方括号内包含以下内容：一个表达式，后面为一个 for 子句，然后，是零个或多个 for 或 if 子句。结果是由表达式依据 for 和 if 子句求值计算而得出一个新列表。 
举例来说，以下列表推导式将两个列表中不相等的元素组合起来
~~~python
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
~~~


#### 5.1.4 嵌套的列表推导式
以下可将矩阵转置
~~~python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]

[[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
~~~

*这里row代表的是matrix中的元素,也就是一个列表,直接用row[]即可取得值*
- 当然 zip()函数直接转置

### 5.2 del语句
与 pop()返回一个值不同,del语句可以移除切片甚至整个列表
- del还能删除变量,此时再引用会报错,直到再次创建

### 5.3 元组和序列
- 列表和字符串有很多共性,如索引和切片,它们都属于序列(数据类型),元组也是一种标准序列类型
**元组(Tuple)**用多个逗号隔开的值组成
~~~python
t = 12345,54321,'hello!'
t[0]
# 12345
t
# (12345, 54321, 'hello!')
~~~

- 输出时会用括号, 方便正确解释嵌套,一般输入时也使用圆括号以标识
- Tuple是inmutable,不允许为单个元素赋值,但可以创建含列表等可变对象的元组


## 模块


## 更多输入和输出

### 7.1 更复杂的输出格式
#### 7.1.1 格式化字符串字面值

#### 7.1.2 字符串 format() 方法

> 位置参数和关键字参数可以任意组合
> 可以传入字典,通过[]访问键完成

#### 7.1.3 手动格式化字符串
- 字符串对象的 str.rjust() 方法通过在左侧填充空格,类似的还有str.ljust() 和 str.center()
这些方法不写入任何内容，只返回一个新字符串
- 另一种方法是 str.zfill() ，该方法在数字字符串左边填充零，且能识别正负号

### 7.2 读写文件
open() 返回一个 file object ，最常使用的是两个位置参数和一个关键字参数：open(filename, mode, encoding=None)
> mode 的值包括 'r' ，表示文件只能读取；'w' 表示只能写入（现有同名文件会被覆盖）；'a' 表示打开文件并追加内容，任何写入的数据会自动添加到文件末尾。'r+' 表示打开文件进行读写。mode 实参是可选的，省略时的默认值为 'r'。
>
> 使用b在encoding的后缀时,不选用编码而是二进制bytes输入

- **with关键字**可以帮助关闭文档,不然就是用f.close()手动关闭

#### 7.2.1 文本对象的方法
- f.read(size):
~~~python
f.read()    # 没有参数,直接读到结尾(内存支持的话)
'This is the entire file.\n'
f.read()    # 没有就读到' '
''
~~~
- f.readline():读取一行,除了最后,结尾都是'\n'
  - 空行是'\n'
  - 结尾是' '
- 循环遍历可以读取整个文件对象,能高效利用内存,且快速简单.
~~~python
for line in f:
    print(line, end='')

This is the first line of the file.
Second line of the file
~~~
- 如需以列表形式读取文件中的所有行，可以用 list(f) 或 f.readlines()。
- f.write(string) 把 string 的内容写入文件，并返回写入的字符数。
- tell(),seek()...

#### 7.2.2 使用JSON保存数据
为了方便读写,Python允许使用json形式保存,通过**标准库模块json**
~~~python
import json
x = [1, 'simple', 'list']
json.dumps(x)
'[1, "simple", "list"]'
~~~
- 这种方法可以简单序列化或反序列化元组和字典
- 对Python对象的处理要用到**pickle - 封存模块**


## 错误和异常
### 8.1 语法错误
### 8.2 异常
### 8.3 异常处理
try-except语句及其原理
- 内置异常可以绑定到异常实例,通过定义好的__str__()函数来访问内置的args属性,而不用显示访问args;
~~~python
try:
    raise Exception('spam', 'eggs')
except Exception as inst:
    print(type(inst))    # the exception type
    print(inst.args)     # arguments stored in .args
    print(inst)          # __str__ allows args to be printed directly,
                         # but may be overridden in exception subclasses
    x, y = inst.args     # unpack args
    print('x =', x)
    print('y =', y)

<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
~~~



## 类
### 9.1 名称和对象
对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。
就如同指针和别名(应该是引用吧,只不过c++引用不能变,但这个可以变)

### 9.2 作用域和命名空间
**namespace**是从名称到对象的映射。
- 有多种不同的命名空间
- 命名空间点号之后的值叫做属性
- 属性可以被改变或删除
- 命名空间是在不同时间创建的
  > 内置名称的namespace在解释器启动时创建
  > 模块的全局命名空间在读取模块定义时创建
  > 函数的局部命名空间在函数被调用时被创建

一个命名空间的 **作用域** 是 Python 代码中的一段文本区域，从这个区域可直接访问该命名空间。
- 执行的任何时刻一般会有3-4个作用域,从内向外搜索
- 如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”
- 要重新绑定在最内层作用域以外找到的变量，可以使用 nonlocal 语句

#### 9.3.3 
**方法** 是从属于 **对象** 的函数
类.func是函数对象,实例.func是方法对象
调用 x.f() 其实就相当于 MyClass.f(x)。
#### 9.4.4 补充说明
- 如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例
- 数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯抽象数据类型。 

### 9.5 继承
- isinstance() ： isinstance(obj, int)
- issubclass() ： issubclass(bool, int)

#### 9.5.1 多重继承
在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左到右的，当层次结构存在重叠时不会在同一个类中搜索两次。 

### 9.6 私有变量
使用一个下划线，如_spam,应当被当作一个api的非公有部分
> 名称改写: 将 _spam 改为 _classname__spam,用以避免冲突

### 9.7 杂项说明
使用dataclass来作为C++"struct"存储数据

### 9.8 迭代器
在幕后，for 语句会在容器对象上调用 iter()。 该函数返回一个定义了 __next__() 方法的迭代器对象，此方法将逐一访问容器中的元素。
> 了解了迭代器协议背后的机制后，就可以轻松地为你的类添加迭代器行为了。 定义 \__iter__() 方法用于返回一个带有 \__next__() 方法的对象。 如果类已定义了 \__next__()，那么 \__iter__() 可以简单地返回 self:

### 9.9 生成器
可以用生成器来完成的任何功能同样可以通用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 __iter__() 和 __next__() 方法。

### 9.10 生成器表达式
某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。


## 标准库简介


### 10.6
SciPy项目 <https://scipy.org> 有许多其他模块用于数值计算。










## * & **
**\*:**
- 收集列表中多余的值,形成一个列表
~~~python
a,b,*c=[1,2,3,4]
~~~
- 涉及到函数了，*号的作用在于收集参数或者分配参数。
  - 定义函数时,\*将调用时提供的所有值，放在一个元组里。两个\*\*会定义一个字典
  - 如果在调用函数时，*和**都是分配参数用的
