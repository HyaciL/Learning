### 0-1背包
动态规划问题，就是将一个大号的问题划分为小的子问题，先解决子问题，再通过子问题的结果解决大的问题。帮助你
帮助你在给定约束条件下找到最优解。
0-1背包就是不断找到一个更小的背包能容纳的最大价值，之后通过新物品与剩余最大价值和当前最大价值比较，来更新最大价值。
- 需要有当前价值最小的度量间隔
- 每个物品之间必须是独立的（子问题必须是离散的），不能存在干扰（不依赖于其他子问题）。



### KNN（K-nearest Neighbors）k-最近邻

- KNN用于回归和分类，考虑k个最近的邻居
  - 回归就是预测结果（如数字）
  - 分类就是编组
- **特征抽取**意味着将对象转化为模型中的数字
- 能否**挑选合适的特征**至关重要
合适的特征：紧密相关，不偏不倚合适的特征：紧密相关，不偏不倚


### 正向索引
例：存储文档时，以文档内关键字为索引，形式类似：
**（文档-单词模型）**
doc1：keyword11：info，->keyword12：info,...
doc2：keyword21：info，->keyword22：info,...
优点：方便建立和维护，当有新的文档出现，只需创建一个新的索引块，挂索在原来索引文件的后面。
缺点：查询时需要对所有的文档进行查询，检索效率太低。

### 反向索引（倒排索引）
形式：
word1：doc1，doc2，...（所有出现了该词的文档）
word2：doc2，doc3，...
缺点：建立和维护更加困难
优点：能够快速检索有关word的所有文档。且建立和维护在服务器端，不会影响整个搜索引擎性能。

应用：搜索引擎实现最普遍的算法
- 单词词典：实现倒排索引时需要将所有出现过的单词存放在词典中，并存储相关的信息和指向“倒排列表”的位置。
- 中文还需要切词系统参与单词划分
- 倒排列表还可以记录（除DocId）出现频率，文档频率，位置信息等信息。


### 傅里叶变换（Fourier Transformm，TF）



### 并行算法
- 不可能线性提升：
    - 并行管理开销
    - 负载均衡

### MapReduce
并行算法，基于两个函数，Map（映射）和Reduce（归并）函数
1. 映射函数
工作列表需要进行同样的工作，也就是映射，映射函数会将工作中的每一项自动分配到不同的计算机进行。
eg：将数组[1,2,3,4,5] --*2--> [2,4,6,8,10]
2. 归并函数
将很多项归并成一项。
eg:将上述[1,2,3,4,5]相加为15.


### 布隆过滤器和HyperLogLog
概率型算法：不一定完全准确，但八九不离十，而且占用空间小。
1. 布隆过滤器（Bloom Filter）
如判断网页是否在恶意网站的集合中，会给出结果：
   1. 可能是恶意网站（因为“存在”判断可能正确）
   2. 不是（“不存在”判断一定正确）

优点：1. 时间复杂度低，增加和查询为O（N），N为哈希函数的个数，通常较小（布隆过滤器对元素应用多个哈希函数获得散列值）。2. 保密性强，不存储元素本身。 3. 占用空间小。 


### SHA（Secure Hash Algorithm）安全散列算法
给定一个字符串，SHA返回散列值。这种算法是单向的。
SHA是一系列函数：SHA-0，...， SHA-3，最安全的是另一种：bcrypt。
1. 应用： 
比较文件是否相同
保存密码的散列值来保密。
2. 局部敏感的散列函数：Simhash
通过散列值，可以检测两项的相似程度，而不会因为局部不同导致散列值完全不同。

### Diffie-Hellman算法
发送消息者通过公钥加密，接收者通过只有接收者拥有的私钥解密。
公钥和私钥是一一对应的，生成后，将公钥公布，发送者通过公钥加密，接收者通过私钥解密。
Diffie-Hellman算法及其替代者RSA仍在广泛使用。
[Diffie-Hellman算法解析](https://zhuanlan.zhihu.com/p/599518034)


### 线性规划
线性规划是在规定约束条件下最优化指标的算法，图算法只是最优化的一个子集
经典的算法有：Simplex算法