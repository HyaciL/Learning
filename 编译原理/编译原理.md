# 程序语言的定义
语言的*语法*是指一组规则，用它可以形成和产生一个合适的程序
阐明语法的一个工具是*文法*，这是形式语言理论的基本概念之一


## 语法描述
### 基本概念
*字母表*： 元素的非空有限**集**
    字母表中的元素成为*符号*
*符号串*： 符号的有穷**序列**
    无任何符号的符号串称为*空符号串*，记作$\epsilon$
    *符号串运算*：|x|->长度
    *符号串连接*: xy    $\epsilon$x=x$\epsilon$=x
    *符号串集合的乘积*: AB={xy|x属于A,y属于B}
    *符号串集合的方幂*:
    *符号串集合的正闭包和自反闭包*

### 文法的直观描述
文法是定义或描述语法结构一组形式规则
一个上下文无关文法包括四个组成成分
四个组成部分构成了一个语法规则

## 文法的形式化定义和分类
四元组G(V_N,V_T,S,P)
前两个都是非空有限的

### 分类
0123型
- 0型(无限制文法): α->β,其中这俩都是由字母表任意元素的任意组合的非空符号串,因为是()+,也就是正闭包
- 1:上下文有关: 右比左边长度长
- 2:上下文无关: 左边属于V_N,右边属于正闭包
- 3:右线性和正规文法: 总是在左边多出一或几个个终结符
- 左线性文法\正规文法(相比右线性,终结符只有一个,且若S->$\epsilon 属于P$,P不能是)\二型扩充(允许有空产生式A->$\epsilon$)

## 文法和语言
- 上下文无关语法定义的语言
- *推导和规约*
- 句型\句子\语言的形式定义
- 语法分析树和二义性

### 推导和规约
定义\一步\多步

最右推导又称规范推导
规范推导的句型称为规范句型

### 句型&句子&语言的形式定义
能从S推导出来的就是*句型*
只有终结符的句型就是*句子*
文法的语言就是该文法*所有句子的集合*
- 如果L(G1)=L(G2)则两个文法G1和G2等价

## 语法分析树
用树形结构图描述句子的推导->语法树
规约->分析树
- 如果没有二义,则两树一样
- 有个句子有两颗树,则有二义

## 总结
程序语言的定义
文法的形式化定义和分类
文法和语言
语法分析树


# 词法分析

## 概述
任务 | 功能 | 安排 | 实现方式 | 输出形式
字符的源程序->单词符号串组成的中间程序
安排:
  - 作为单独的一遍
  - 作为语法分析的子程序 

## 词法分析程序设计
### 状态转换图
### 状态转换图实现

## 正规式和有限自动机
### 基本概念
字母表 | 字符 | 字母表上的字 | 空字 | ...
正规式和正规集
正规式u的正规集使用L(u)标识
- $\epsilon$和$\phi$都是正规集,对应{$\epsilon$}和$\phi$ 等三个规则定义正规式和正规集
- 优先级
- 正规式的性质

### DFA
一个DFA M识别的字的全体记作L(M)
- D=（K，Σ，M，S，F）
- M: 转换函数，是在K×Σ→K上的映像（笛卡尔积）
- 
### NFA
当前状态下同一输入的下一状态不止一个
- M：转换函数，是在K×Σ到K的子集所组成集合的映像
- S属于K是非空的初态集合
### 正规式和DFA的等价性
**一、Σ上NFA M所能识别的字的全体是Σ上的一个正规集**
证明：
1. 添加X&Y两个节点
2. *消结点*
3. 得结论
**二、对于Σ上的每个正规集V，存在一个Σ上的DFA M，使得V=L（M）**
证明：
1. 替代办法构造一个NFA M',使V=L(M'),因为正规集可用正规式u表示,将u分解可得...
2. 把NFA M'确定化

$\epsilon$-CLOSURE(I)为I的$\epsilon$-闭包
$I_a=\epsilon-CLOSURE(J)$: 从I中任意状态出发,跳过任意条$\epsilon$弧,经过一条a能到达的状态结的全体.

使用以上两个概念可以将NFA确定化
算法此处不再表述

### DFA化简

s和t(M的两个状态)是等价的:从s出发能读出字w停于终态,从t也可以,反之亦然.
化简算法步骤:
1. 划分状态集
2. 合并状态,取代表状态,删去其余
3. 删除死状态和不可达状态
具体实现:
1. 分开终态和非终态,形成基本划分 Ⅱ, 随后处理在某个时刻的 Ⅱ中的每个子集I,看是否能继续分划.
  对于某个I,令I={q^1,q^2...q^k},若存在输入字符a,使得I_a不全包含在现有Ⅱ中的一个子集中,就分开.

## 词法分析器的自动生成

LEX语言
LEX源程序包含:
- 辅助定义式
  - $D_1->R_1$
  - 例:Digit->0|1|...|9
       Id->Letter(Letter|Digit)*
- 识别规则
  - $P_1{A_1} P_i称为词形,A_i称为词形的动作(程序)$
  - LEX源程序产生的词法分析器只能识别如P_i的单词
- LEX编译程序目的是把LEX程序改造为词法分析器L.
- L的工作方法:寻找一个最大子串匹配某P_i
- 编译过程:
    1. 对每个P_i构造一个NFA M_i
    2. 引入一个新初态X,画到M_i的初态
    3. 改为DFA

### 实现实例
见PPT
给个程序
~~~LEX
  PROGRAM LEX(input,output)
  BEGIN   TOKEN:=’’;  getchar;
          CASE char OF
         ‘0’..’9’:  [while char IN[‘0’..’9’]DO
            BEGIN TOKEN:=TOKEN+char; getchar
            END;  retract;
            IF VAL(token,value)  THEN return(4,value)];
         ‘A’..’Z’:[while char IN[‘A’..’Z’,’0’..’9’]DO 
            BEGIN TOKEN:=TOKEN+char; getchar
            END;  retract;
            Return(5,token)];
         ‘*’:             [getchar;
            IF char=’*’  THEN Return(7,-)
            ELSE  retract;Return(6,-)];
         ELSE:             ERROR;
         END{of case};
  END;
~~~

# 语法分析-自上而下分析

## 语法分析简介

任务:判定语法结构是否符合语法规则
- 语言的语法结构用上下文无关文法描述

*语法分析器*
  功能:按照产生式,识别输入符号串是否为一个句子
  关键:判断从文法开始符号出发能否推断这个字符串,或者说建立匹配的*语法分析树*

方法:
- 自下而上分析法:逐步归约
- 自上而下分析法:从开始符号开始,正向推导句子,或者说建立所有叶结点

## 自上而下分析简介
总之就是有很多问题
比如左递归和回溯

## 消除左递归和回溯

### 左递归的消除
1. 直接左递归的消除
2. 完全消除左递归
### 提取左因子、消除回溯
*FIRST(α)*:...
- 若α多步推导可得空字,则空字属于FIRST(α)
应用:如果一个文法G的非终结符A的多个候选式之首符集两两不相交,则自上而下分析可以消除回溯
例:A->α_1|α_2|α_3|...|α_n的FIRSR集两两不相交,则可以根据输入符号a准确选用候选式
方法:**提取公共左因子**

### LL(1)分析法
实现自上而下分析的另一种有效方法,使用一个*分析栈*和一张*分析表*
分析表元素M[A,a]:非终结符A遇到输入符号a,采取的产生式

## 算符优先文法



### 算符优先文法的定义
算符优先分析过程是自下而上的归约过程，但未必是严格的最左归约。也就是说，算符优先分析法不是一种规范归约法。所谓【算符优先分析法】就是定义算符之间的某种优先关系，借助于这种关系寻找“可归约串”进行归约的一种方法。

如果一个算法文法 G 中的任何终结符对(a,b)至多满足下述三关系之一：a<b,a=b,a>b，则称G是一个算符优先文法。

### FIRSTVT&LASTVT的定义
