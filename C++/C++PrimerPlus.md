# C++ Primer Plus


## 第七章 函数

### 7.10 函数指针



## 第八章 函数探幽
### 8.1 内联函数

### 8.2 引用变量
**引用变量**是一种伪装指针,主要用作处理结构和类对象的函数的参数.
- 基类引用可以指向派生类对象

### 8.3 默认参数
只能从右到左提供*默认参数*
### 8.4 函数重载
函数特征标:函数重载的关键--***参数列表***
没有对应的函数定义时,会进行强制转换;
- 有多个可转换函数对象时,报错
- 不能共存的函数特征标
  - 类型引用和类型本身视为同一个
  - 不区分const和非const

### 8.5 函数模板
#### 显式具体化
#### 隐式实例化和显式实例化

#### 编译器选择函数
重载解析：
1. 创建候选函数列表：名称相同的函数和模板；
2. 创建可行函数列表：参数数目正确的函数（包含隐式转换）
   >int型不能隐式转换为double* 或赋给double&;
3. 选择：
   1. 完全匹配和最佳匹配:如果由多个完全匹配,可能会报Ambiguous(二义性错误)
    > 特例:指向非const数据的指针和引用,优先与非const指针和引用匹配;
    > 另一特例就是模板等
    - 模板匹配时根据"most specialized",值编译器推断使用那种类型执行的转换最少
    - 用于找出最具体模板的规则称为函数模板的**部分排序规则**,和显式示例一样,C++98新增;

#### 模板函数的发展
##### 不确定类型问题
如当存在类型提升时，可能不知道应该使用什么类型；
~~~c++
template<class T1,class T2>
void ft(T1 x,T2 y)
{
   ...
   ?type> xpy = x+y;
   ...
}
~~~
C++11新增关键字： **decltype**
~~~c++
int x;
decltype(x)y; //make y the same type as x;
//应用如下
decltype(x+y)xpy;
xpy = x+y;
~~~
decltype中，为确定类型，编译器必须遍历一个**核对表**；
另一种无法解决的情况，函数返回值不明确时，要在声明参数后使用decltype（），即使用**后置返回类型**；
~~~c++
auto h(int x,double y) ->decltype(x+y)
{
   ...
}
~~~
此时decltype(x+y)在作用域内;


## 第九章 内存模型和名称空间
### 9.1 单独编译
C++可以单独修改并编译文件,并与其他文件的编译版本链接,如在UNIX系统中的make程序和IDE都有这个功能;
因此：
- 将结构和使用该结构的函数声明放入头文件；
- 将与结构有关的函数的代码放入源代码文件；
- 将包含调用与结构有关的函数的代码放入源代码文件；
> 不要将定义放在头文件,可能导致一个程序两个定义;

**适合放在头文件中的内容:**
- 函数原型 & 使用#define或const定义的符号常量 & 结构声明 & 
- 类声明 & 模板声明 & 内联函数 
> 其中, 结构声明和模板并不创建变量,而const数据和内联函数由特殊的链接属性
> 文件名在尖括号<>中时,编译器将在储存标准头文件的主机系统里查找,双引号""则会先在工作目录寻找;
> 头文件不在项目列表中

#### 头文件管理技术
~~~C++
#infdef
#define COORIDIN     //将#define用于定义一个名称
...
#endif
~~~
> 讨论的根据文件单独编译,但C++中使用术语**翻译单元**

### 9.2 存储持续性&作用域&连接性

#### 作用域 & 链接
**作用域(scope)** : 描述了名称的可见范围
- 代码块
- 全局(文件作用域)到文件结尾都可用
- 自动变量的scope为局部
- 静态变量取决于如何定义的
- function prototype scope中的名称只在参数列表的括号中可用(所以名称存在与否和是什么无所谓的)
- 类中成员scope为整个类
- 名称空间中的变量scope为整个名称空间
- **函数的作用域**的作用域为整个类或名称空间,但不能是局部的(因为不能在代码块内定义函数)
**链接性(linkage)** : 描述了名称如何在不同单元间共享
- linkage为外部的名称可在文件间共享,内部不行,自动变量没有链接性,因为它们不能共享;

#### 储存数据的方案
- 自动存储持续性 : 函数定义中声明的变量,从开始执行函数或代码块到执行结束;  C++中有两种;
- 静态存储持续性 : 在函数定义外定义的变量和使用static定义的变量的储存持续性为静态,整个程序的运行过程中都存在;  C++中有三种;
- 线程存储持续性 : (c++11) 关键字thread_local声明变量生命周期和所属线程一样长;
- 动态存储持续性 : 用new运算分配的一直存在,知道delete或程序结束,也叫free store 或 **heap**;

#### 9.2.2自动存储持续性
默认情况下,函数中的参数和变量存储持续性为自动,作用域为局部,没有链接性
**自动变量**在这里指的就是这种函数中的变量
> 执行到变量所属代码块时,将为变量分配内存,但其作用域起点在声明位置;  **?为什么**
> 新变量隐藏(hide)同名旧变量
> **C++11中,auto用于自动类型推断,但在之前,auto是显式指出自动存储**
> 自动变量通过栈实现
##### 寄存器变量
~~~c++
register int count_fast;
~~~
申请一个寄存器;
旨在提高访问变量的速度
C++11后,不再有这个功能,只是显式指出变量是自动的(跟auto一个味儿了成)
保留register关键字的原因是防止用了这个的代码出问题
#### 9.2.3 静态持续变量
- C++同C一样,为静态存储持续性变量提供三种链接性 : 外部链接性,内部链接型和无链接性(只能在当前函数|代码块)
- 都在整个程序执行期间存在
- 编译器将分配固定的内存块来存储;
~~~c++
int global = 10;     //static duration, external linkage;
static int one file = 50;     //static duration, internal linkage; 
{
   static int count = 0;      //static duration, no linkage;
   int llama = 0;    //count 在函数没有被执行时也在内存中
}
~~~
> 未被初始化的静态持续变量
#### 9.2.4 静态持续性 & 外部链接性
链接性为外部的变量简称为**外部变量**,存储持续性为静态,作用域为整个文件,相对于局部的自动变量,也称为全局变量;
1. 单定义规则
   两种变量声明
   - 定义声明(defining declaration) 简称**定义(definition)** : 分配储存空间
   - 引用声明(referencing declaration) 简称**声明(declaration)** : 不给变量分配储存空间
     - 使用关键字extern
     - 在一个文件中包含定义,其他文件中使用extern声明;
     - 如果没有还没有定义,即使有extern关键字也是定义(definition)
     - 同名局部变量会隐藏全局变量,通过在函数内再次extern type variable,或者::variable,可以声明使用全局变量;
#### 9.2.5 静态持续性 & 内部链接性
内部链接性变量 可以隐藏 其他文件的 全局变量

> 使用外部变量在多文件共享数据, 使用静态内部链接变量在同一文件内共享数据

#### 9.2.6 静态存储持续性 & 无链接性
如果初始化了静态局部变量,则程序只在启动时进行一次初始化;
#### 9.2.7 说明符 & 限定符
存储说明符 或cv-限定符的C++关键字提供了其他有关存储的信息
- auto（C++11种不再是说明符）：现在用于自动类型推断
- register：现在用于显式指出变量是自动的
- static
- extern
- thread——local（C++11新增）：可与static或extern结合使用
- mutable：含义根据const解释
**cv-限定符**：
- const：表明内存被初始化后程序员不能在进行修改
- volatile；即使程序代码没有对内存单元进行修改，其值也可能发生改变；如硬件改变了串行端口的时间或信息
   >将变量声明为volatile,相当于告诉编译器不要进行如下优化:当程序在几条语句中使用两次同一变量,将把这个值存在寄存器中从而简化两次访问(编译器假设两次之间值不改变)

**mutable**限定符:指出即使结构(或类)变量为const,其某个成员也可以被修改;在const的变量中给成员变量定义为mutable;
   
### 9.3 名称空间
